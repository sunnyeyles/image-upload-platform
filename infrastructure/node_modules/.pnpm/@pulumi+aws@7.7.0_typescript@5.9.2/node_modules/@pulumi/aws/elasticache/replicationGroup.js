"use strict";
// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReplicationGroup = void 0;
const pulumi = require("@pulumi/pulumi");
const utilities = require("../utilities");
/**
 * Provides an ElastiCache Replication Group resource.
 *
 * For working with a [Memcached cluster](https://docs.aws.amazon.com/AmazonElastiCache/latest/mem-ug/WhatIs.html) or a
 * [single-node Redis instance (Cluster Mode Disabled)](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/WhatIs.html),
 * see the `aws.elasticache.Cluster` resource.
 *
 * > **Note:** When you change an attribute, such as `engineVersion`, by
 * default the ElastiCache API applies it in the next maintenance window. Because
 * of this, this provider may report a difference in its planning phase because the
 * actual modification has not yet taken place. You can use the
 * `applyImmediately` flag to instruct the service to apply the change
 * immediately. Using `applyImmediately` can result in a brief downtime as
 * servers reboots.
 * See the AWS Documentation on
 * [Modifying an ElastiCache Cache Cluster](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Clusters.Modify.html)
 * for more information.
 *
 * > **Note:** Any attribute changes that re-create the resource will be applied immediately, regardless of the value of `applyImmediately`.
 *
 * > **Note:** Be aware of the terminology collision around "cluster" for `aws.elasticache.ReplicationGroup`. For example, it is possible to create a ["Cluster Mode Disabled [Redis] Cluster"](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Clusters.Create.CON.Redis.html). With "Cluster Mode Enabled", the data will be stored in shards (called "node groups"). See [Redis Cluster Configuration](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/cluster-create-determine-requirements.html#redis-cluster-configuration) for a diagram of the differences. To enable cluster mode, use a parameter group that has cluster mode enabled. The default parameter groups provided by AWS end with ".cluster.on", for example `default.redis6.x.cluster.on`.
 *
 * ## Example Usage
 *
 * ### Redis OSS/Valkey Cluster Mode Disabled
 *
 * To create a single shard primary with single read replica:
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.elasticache.ReplicationGroup("example", {
 *     automaticFailoverEnabled: true,
 *     preferredCacheClusterAzs: [
 *         "us-west-2a",
 *         "us-west-2b",
 *     ],
 *     replicationGroupId: "tf-rep-group-1",
 *     description: "example description",
 *     nodeType: "cache.m4.large",
 *     numCacheClusters: 2,
 *     parameterGroupName: "default.redis3.2",
 *     port: 6379,
 * });
 * ```
 *
 * You have two options for adjusting the number of replicas:
 *
 * * Adjusting `numCacheClusters` directly. This will attempt to automatically add or remove replicas, but provides no granular control (e.g., preferred availability zone, cache cluster ID) for the added or removed replicas. This also currently expects cache cluster IDs in the form of `replication_group_id-00#`.
 * * Otherwise for fine grained control of the underlying cache clusters, they can be added or removed with the `aws.elasticache.Cluster` resource and its `replicationGroupId` attribute. In this situation, you will need to utilize [`ignoreChanges`](https://www.pulumi.com/docs/intro/concepts/programming-model/#ignorechanges) to prevent perpetual differences with the `numberCacheCluster` attribute.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.elasticache.ReplicationGroup("example", {
 *     automaticFailoverEnabled: true,
 *     preferredCacheClusterAzs: [
 *         "us-west-2a",
 *         "us-west-2b",
 *     ],
 *     replicationGroupId: "tf-rep-group-1",
 *     description: "example description",
 *     nodeType: "cache.m4.large",
 *     numCacheClusters: 2,
 *     parameterGroupName: "default.redis3.2",
 *     port: 6379,
 * });
 * const replica: aws.elasticache.Cluster[] = [];
 * for (const range = {value: 0}; range.value < 1; range.value++) {
 *     replica.push(new aws.elasticache.Cluster(`replica-${range.value}`, {
 *         clusterId: `tf-rep-group-1-${range.value}`,
 *         replicationGroupId: example.id,
 *     }));
 * }
 * ```
 *
 * ### Redis OSS/Valkey Cluster Mode Enabled
 *
 * To create two shards with a primary and a single read replica each:
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const baz = new aws.elasticache.ReplicationGroup("baz", {
 *     replicationGroupId: "tf-redis-cluster",
 *     description: "example description",
 *     nodeType: "cache.t2.small",
 *     port: 6379,
 *     parameterGroupName: "default.redis3.2.cluster.on",
 *     automaticFailoverEnabled: true,
 *     numNodeGroups: 2,
 *     replicasPerNodeGroup: 1,
 * });
 * ```
 *
 * ### Redis Log Delivery configuration
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const test = new aws.elasticache.ReplicationGroup("test", {
 *     replicationGroupId: "myreplicaciongroup",
 *     description: "test description",
 *     nodeType: "cache.t3.small",
 *     port: 6379,
 *     applyImmediately: true,
 *     autoMinorVersionUpgrade: false,
 *     maintenanceWindow: "tue:06:30-tue:07:30",
 *     snapshotWindow: "01:00-02:00",
 *     logDeliveryConfigurations: [
 *         {
 *             destination: example.name,
 *             destinationType: "cloudwatch-logs",
 *             logFormat: "text",
 *             logType: "slow-log",
 *         },
 *         {
 *             destination: exampleAwsKinesisFirehoseDeliveryStream.name,
 *             destinationType: "kinesis-firehose",
 *             logFormat: "json",
 *             logType: "engine-log",
 *         },
 *     ],
 * });
 * ```
 *
 * > **Note:** We currently do not support passing a `primaryClusterId` in order to create the Replication Group.
 *
 * > **Note:** Automatic Failover is unavailable for Redis versions earlier than 2.8.6,
 * and unavailable on T1 node types. For T2 node types, it is only available on Redis version 3.2.4 or later with cluster mode enabled. See the [High Availability Using Replication Groups](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Replication.html) guide
 * for full details on using Replication Groups.
 *
 * ### Creating a secondary replication group for a global replication group
 *
 * A Global Replication Group can have up to two secondary Replication Groups in different regions. These are added to an existing Global Replication Group.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const primary = new aws.elasticache.ReplicationGroup("primary", {
 *     replicationGroupId: "example-primary",
 *     description: "primary replication group",
 *     engine: "redis",
 *     engineVersion: "5.0.6",
 *     nodeType: "cache.m5.large",
 *     numCacheClusters: 1,
 * });
 * const example = new aws.elasticache.GlobalReplicationGroup("example", {
 *     globalReplicationGroupIdSuffix: "example",
 *     primaryReplicationGroupId: primary.id,
 * });
 * const secondary = new aws.elasticache.ReplicationGroup("secondary", {
 *     replicationGroupId: "example-secondary",
 *     description: "secondary replication group",
 *     globalReplicationGroupId: example.globalReplicationGroupId,
 *     numCacheClusters: 1,
 * });
 * ```
 *
 * ### Redis AUTH and In-Transit Encryption Enabled
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.elasticache.ReplicationGroup("example", {
 *     replicationGroupId: "example",
 *     description: "example with authentication",
 *     nodeType: "cache.t2.micro",
 *     numCacheClusters: 1,
 *     port: 6379,
 *     subnetGroupName: exampleAwsElasticacheSubnetGroup.name,
 *     securityGroupIds: [exampleAwsSecurityGroup.id],
 *     parameterGroupName: "default.redis5.0",
 *     engineVersion: "5.0.6",
 *     transitEncryptionEnabled: true,
 *     authToken: "abcdefgh1234567890",
 *     authTokenUpdateStrategy: "ROTATE",
 * });
 * ```
 *
 * > When adding a new `authToken` to a previously passwordless replication group, using the `ROTATE` update strategy will result in support for **both** the new token and passwordless authentication. To immediately require authorization when adding the initial token, use the `SET` strategy instead. See the [Authenticating with the Redis AUTH command](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/auth.html) guide for additional details.
 *
 * ## Import
 *
 * Using `pulumi import`, import ElastiCache Replication Groups using the `replication_group_id`. For example:
 *
 * ```sh
 * $ pulumi import aws:elasticache/replicationGroup:ReplicationGroup my_replication_group replication-group-1
 * ```
 */
class ReplicationGroup extends pulumi.CustomResource {
    /**
     * Get an existing ReplicationGroup resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    static get(name, id, state, opts) {
        return new ReplicationGroup(name, state, { ...opts, id: id });
    }
    /**
     * Returns true if the given object is an instance of ReplicationGroup.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    static isInstance(obj) {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ReplicationGroup.__pulumiType;
    }
    constructor(name, argsOrState, opts) {
        let resourceInputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState;
            resourceInputs["applyImmediately"] = state?.applyImmediately;
            resourceInputs["arn"] = state?.arn;
            resourceInputs["atRestEncryptionEnabled"] = state?.atRestEncryptionEnabled;
            resourceInputs["authToken"] = state?.authToken;
            resourceInputs["authTokenUpdateStrategy"] = state?.authTokenUpdateStrategy;
            resourceInputs["autoMinorVersionUpgrade"] = state?.autoMinorVersionUpgrade;
            resourceInputs["automaticFailoverEnabled"] = state?.automaticFailoverEnabled;
            resourceInputs["clusterEnabled"] = state?.clusterEnabled;
            resourceInputs["clusterMode"] = state?.clusterMode;
            resourceInputs["configurationEndpointAddress"] = state?.configurationEndpointAddress;
            resourceInputs["dataTieringEnabled"] = state?.dataTieringEnabled;
            resourceInputs["description"] = state?.description;
            resourceInputs["engine"] = state?.engine;
            resourceInputs["engineVersion"] = state?.engineVersion;
            resourceInputs["engineVersionActual"] = state?.engineVersionActual;
            resourceInputs["finalSnapshotIdentifier"] = state?.finalSnapshotIdentifier;
            resourceInputs["globalReplicationGroupId"] = state?.globalReplicationGroupId;
            resourceInputs["ipDiscovery"] = state?.ipDiscovery;
            resourceInputs["kmsKeyId"] = state?.kmsKeyId;
            resourceInputs["logDeliveryConfigurations"] = state?.logDeliveryConfigurations;
            resourceInputs["maintenanceWindow"] = state?.maintenanceWindow;
            resourceInputs["memberClusters"] = state?.memberClusters;
            resourceInputs["multiAzEnabled"] = state?.multiAzEnabled;
            resourceInputs["networkType"] = state?.networkType;
            resourceInputs["nodeType"] = state?.nodeType;
            resourceInputs["notificationTopicArn"] = state?.notificationTopicArn;
            resourceInputs["numCacheClusters"] = state?.numCacheClusters;
            resourceInputs["numNodeGroups"] = state?.numNodeGroups;
            resourceInputs["parameterGroupName"] = state?.parameterGroupName;
            resourceInputs["port"] = state?.port;
            resourceInputs["preferredCacheClusterAzs"] = state?.preferredCacheClusterAzs;
            resourceInputs["primaryEndpointAddress"] = state?.primaryEndpointAddress;
            resourceInputs["readerEndpointAddress"] = state?.readerEndpointAddress;
            resourceInputs["region"] = state?.region;
            resourceInputs["replicasPerNodeGroup"] = state?.replicasPerNodeGroup;
            resourceInputs["replicationGroupId"] = state?.replicationGroupId;
            resourceInputs["securityGroupIds"] = state?.securityGroupIds;
            resourceInputs["securityGroupNames"] = state?.securityGroupNames;
            resourceInputs["snapshotArns"] = state?.snapshotArns;
            resourceInputs["snapshotName"] = state?.snapshotName;
            resourceInputs["snapshotRetentionLimit"] = state?.snapshotRetentionLimit;
            resourceInputs["snapshotWindow"] = state?.snapshotWindow;
            resourceInputs["subnetGroupName"] = state?.subnetGroupName;
            resourceInputs["tags"] = state?.tags;
            resourceInputs["tagsAll"] = state?.tagsAll;
            resourceInputs["transitEncryptionEnabled"] = state?.transitEncryptionEnabled;
            resourceInputs["transitEncryptionMode"] = state?.transitEncryptionMode;
            resourceInputs["userGroupIds"] = state?.userGroupIds;
        }
        else {
            const args = argsOrState;
            if (args?.description === undefined && !opts.urn) {
                throw new Error("Missing required property 'description'");
            }
            resourceInputs["applyImmediately"] = args?.applyImmediately;
            resourceInputs["atRestEncryptionEnabled"] = args?.atRestEncryptionEnabled;
            resourceInputs["authToken"] = args?.authToken ? pulumi.secret(args.authToken) : undefined;
            resourceInputs["authTokenUpdateStrategy"] = args?.authTokenUpdateStrategy;
            resourceInputs["autoMinorVersionUpgrade"] = args?.autoMinorVersionUpgrade;
            resourceInputs["automaticFailoverEnabled"] = args?.automaticFailoverEnabled;
            resourceInputs["clusterMode"] = args?.clusterMode;
            resourceInputs["dataTieringEnabled"] = args?.dataTieringEnabled;
            resourceInputs["description"] = args?.description;
            resourceInputs["engine"] = args?.engine;
            resourceInputs["engineVersion"] = args?.engineVersion;
            resourceInputs["finalSnapshotIdentifier"] = args?.finalSnapshotIdentifier;
            resourceInputs["globalReplicationGroupId"] = args?.globalReplicationGroupId;
            resourceInputs["ipDiscovery"] = args?.ipDiscovery;
            resourceInputs["kmsKeyId"] = args?.kmsKeyId;
            resourceInputs["logDeliveryConfigurations"] = args?.logDeliveryConfigurations;
            resourceInputs["maintenanceWindow"] = args?.maintenanceWindow;
            resourceInputs["multiAzEnabled"] = args?.multiAzEnabled;
            resourceInputs["networkType"] = args?.networkType;
            resourceInputs["nodeType"] = args?.nodeType;
            resourceInputs["notificationTopicArn"] = args?.notificationTopicArn;
            resourceInputs["numCacheClusters"] = args?.numCacheClusters;
            resourceInputs["numNodeGroups"] = args?.numNodeGroups;
            resourceInputs["parameterGroupName"] = args?.parameterGroupName;
            resourceInputs["port"] = args?.port;
            resourceInputs["preferredCacheClusterAzs"] = args?.preferredCacheClusterAzs;
            resourceInputs["region"] = args?.region;
            resourceInputs["replicasPerNodeGroup"] = args?.replicasPerNodeGroup;
            resourceInputs["replicationGroupId"] = args?.replicationGroupId;
            resourceInputs["securityGroupIds"] = args?.securityGroupIds;
            resourceInputs["securityGroupNames"] = args?.securityGroupNames;
            resourceInputs["snapshotArns"] = args?.snapshotArns;
            resourceInputs["snapshotName"] = args?.snapshotName;
            resourceInputs["snapshotRetentionLimit"] = args?.snapshotRetentionLimit;
            resourceInputs["snapshotWindow"] = args?.snapshotWindow;
            resourceInputs["subnetGroupName"] = args?.subnetGroupName;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["transitEncryptionEnabled"] = args?.transitEncryptionEnabled;
            resourceInputs["transitEncryptionMode"] = args?.transitEncryptionMode;
            resourceInputs["userGroupIds"] = args?.userGroupIds;
            resourceInputs["arn"] = undefined /*out*/;
            resourceInputs["clusterEnabled"] = undefined /*out*/;
            resourceInputs["configurationEndpointAddress"] = undefined /*out*/;
            resourceInputs["engineVersionActual"] = undefined /*out*/;
            resourceInputs["memberClusters"] = undefined /*out*/;
            resourceInputs["primaryEndpointAddress"] = undefined /*out*/;
            resourceInputs["readerEndpointAddress"] = undefined /*out*/;
            resourceInputs["tagsAll"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["authToken"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(ReplicationGroup.__pulumiType, name, resourceInputs, opts);
    }
}
exports.ReplicationGroup = ReplicationGroup;
/** @internal */
ReplicationGroup.__pulumiType = 'aws:elasticache/replicationGroup:ReplicationGroup';
//# sourceMappingURL=replicationGroup.js.map