"use strict";
// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
Object.defineProperty(exports, "__esModule", { value: true });
exports.Table = void 0;
const pulumi = require("@pulumi/pulumi");
const utilities = require("../utilities");
/**
 * Provides a DynamoDB table resource.
 *
 * > **Note:** It is recommended to use [`ignoreChanges`](https://www.pulumi.com/docs/intro/concepts/programming-model/#ignorechanges) for `readCapacity` and/or `writeCapacity` if there's `autoscaling policy` attached to the table.
 *
 * > **Note:** When using aws.dynamodb.TableReplica with this resource, use `lifecycle` `ignoreChanges` for `replica`, _e.g._, `lifecycle { ignoreChanges = [replica] }`.
 *
 * ## DynamoDB Table attributes
 *
 * Only define attributes on the table object that are going to be used as:
 *
 * * Table hash key or range key
 * * LSI or GSI hash key or range key
 *
 * The DynamoDB API expects attribute structure (name and type) to be passed along when creating or updating GSI/LSIs or creating the initial table. In these cases it expects the Hash / Range keys to be provided. Because these get re-used in numerous places (i.e the table's range key could be a part of one or more GSIs), they are stored on the table object to prevent duplication and increase consistency. If you add attributes here that are not used in these scenarios it can cause an infinite loop in planning.
 *
 * ## Example Usage
 *
 * ### Basic Example
 *
 * The following dynamodb table description models the table and GSI shown in the [AWS SDK example documentation](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html)
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const basic_dynamodb_table = new aws.dynamodb.Table("basic-dynamodb-table", {
 *     name: "GameScores",
 *     billingMode: "PROVISIONED",
 *     readCapacity: 20,
 *     writeCapacity: 20,
 *     hashKey: "UserId",
 *     rangeKey: "GameTitle",
 *     attributes: [
 *         {
 *             name: "UserId",
 *             type: "S",
 *         },
 *         {
 *             name: "GameTitle",
 *             type: "S",
 *         },
 *         {
 *             name: "TopScore",
 *             type: "N",
 *         },
 *     ],
 *     ttl: {
 *         attributeName: "TimeToExist",
 *         enabled: true,
 *     },
 *     globalSecondaryIndexes: [{
 *         name: "GameTitleIndex",
 *         hashKey: "GameTitle",
 *         rangeKey: "TopScore",
 *         writeCapacity: 10,
 *         readCapacity: 10,
 *         projectionType: "INCLUDE",
 *         nonKeyAttributes: ["UserId"],
 *     }],
 *     tags: {
 *         Name: "dynamodb-table-1",
 *         Environment: "production",
 *     },
 * });
 * ```
 *
 * ### Global Tables
 *
 * This resource implements support for [DynamoDB Global Tables V2 (version 2019.11.21)](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html) via `replica` configuration blocks. For working with [DynamoDB Global Tables V1 (version 2017.11.29)](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V1.html), see the `aws.dynamodb.GlobalTable` resource.
 *
 * > **Note:** aws.dynamodb.TableReplica is an alternate way of configuring Global Tables. Do not use `replica` configuration blocks of `aws.dynamodb.Table` together with aws_dynamodb_table_replica.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.dynamodb.Table("example", {
 *     name: "example",
 *     hashKey: "TestTableHashKey",
 *     billingMode: "PAY_PER_REQUEST",
 *     streamEnabled: true,
 *     streamViewType: "NEW_AND_OLD_IMAGES",
 *     attributes: [{
 *         name: "TestTableHashKey",
 *         type: "S",
 *     }],
 *     replicas: [
 *         {
 *             regionName: "us-east-2",
 *         },
 *         {
 *             regionName: "us-west-2",
 *         },
 *     ],
 * });
 * ```
 *
 * ### Global Tables with Multi-Region Strong Consistency
 *
 * A global table configured for Multi-Region strong consistency (MRSC) provides the ability to perform a strongly consistent read with multi-Region scope. Performing a strongly consistent read on an MRSC table ensures you're always reading the latest version of an item, irrespective of the Region in which you're performing the read.
 *
 * **Note** Please see detailed information, restrictions, caveats etc on the [AWS Support Page](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/multi-region-strong-consistency-gt.html).
 *
 * Consistency Mode (`consistencyMode`) is a new argument on the embedded `replica` that allows you to configure consistency mode for Global Tables.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.dynamodb.Table("example", {
 *     name: "example",
 *     hashKey: "TestTableHashKey",
 *     billingMode: "PAY_PER_REQUEST",
 *     streamEnabled: true,
 *     streamViewType: "NEW_AND_OLD_IMAGES",
 *     attributes: [{
 *         name: "TestTableHashKey",
 *         type: "S",
 *     }],
 *     replicas: [
 *         {
 *             regionName: "us-east-2",
 *             consistencyMode: "STRONG",
 *         },
 *         {
 *             regionName: "us-west-2",
 *             consistencyMode: "STRONG",
 *         },
 *     ],
 * });
 * ```
 *
 * ### Replica Tagging
 *
 * You can manage global table replicas' tags in various ways. This example shows using `replica.*.propagate_tags` for the first replica and the `aws.dynamodb.Tag` resource for the other.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * import * as std from "@pulumi/std";
 *
 * const current = aws.getRegion({});
 * const alternate = aws.getRegion({});
 * const third = aws.getRegion({});
 * const example = new aws.dynamodb.Table("example", {
 *     billingMode: "PAY_PER_REQUEST",
 *     hashKey: "TestTableHashKey",
 *     name: "example-13281",
 *     streamEnabled: true,
 *     streamViewType: "NEW_AND_OLD_IMAGES",
 *     attributes: [{
 *         name: "TestTableHashKey",
 *         type: "S",
 *     }],
 *     replicas: [
 *         {
 *             regionName: alternate.then(alternate => alternate.name),
 *         },
 *         {
 *             regionName: third.then(third => third.name),
 *             propagateTags: true,
 *         },
 *     ],
 *     tags: {
 *         Architect: "Eleanor",
 *         Zone: "SW",
 *     },
 * });
 * const exampleTag = new aws.dynamodb.Tag("example", {
 *     resourceArn: pulumi.all([example.arn, current, alternate]).apply(([arn, current, alternate]) => std.replaceOutput({
 *         text: arn,
 *         search: current.region,
 *         replace: alternate.name,
 *     })).apply(invoke => invoke.result),
 *     key: "Architect",
 *     value: "Gigi",
 * });
 * ```
 *
 * ## Import
 *
 * Using `pulumi import`, import DynamoDB tables using the `name`. For example:
 *
 * ```sh
 * $ pulumi import aws:dynamodb/table:Table basic-dynamodb-table GameScores
 * ```
 */
class Table extends pulumi.CustomResource {
    /**
     * Get an existing Table resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    static get(name, id, state, opts) {
        return new Table(name, state, { ...opts, id: id });
    }
    /**
     * Returns true if the given object is an instance of Table.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    static isInstance(obj) {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Table.__pulumiType;
    }
    constructor(name, argsOrState, opts) {
        let resourceInputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState;
            resourceInputs["arn"] = state?.arn;
            resourceInputs["attributes"] = state?.attributes;
            resourceInputs["billingMode"] = state?.billingMode;
            resourceInputs["deletionProtectionEnabled"] = state?.deletionProtectionEnabled;
            resourceInputs["globalSecondaryIndexes"] = state?.globalSecondaryIndexes;
            resourceInputs["hashKey"] = state?.hashKey;
            resourceInputs["importTable"] = state?.importTable;
            resourceInputs["localSecondaryIndexes"] = state?.localSecondaryIndexes;
            resourceInputs["name"] = state?.name;
            resourceInputs["onDemandThroughput"] = state?.onDemandThroughput;
            resourceInputs["pointInTimeRecovery"] = state?.pointInTimeRecovery;
            resourceInputs["rangeKey"] = state?.rangeKey;
            resourceInputs["readCapacity"] = state?.readCapacity;
            resourceInputs["region"] = state?.region;
            resourceInputs["replicas"] = state?.replicas;
            resourceInputs["restoreDateTime"] = state?.restoreDateTime;
            resourceInputs["restoreSourceName"] = state?.restoreSourceName;
            resourceInputs["restoreSourceTableArn"] = state?.restoreSourceTableArn;
            resourceInputs["restoreToLatestTime"] = state?.restoreToLatestTime;
            resourceInputs["serverSideEncryption"] = state?.serverSideEncryption;
            resourceInputs["streamArn"] = state?.streamArn;
            resourceInputs["streamEnabled"] = state?.streamEnabled;
            resourceInputs["streamLabel"] = state?.streamLabel;
            resourceInputs["streamViewType"] = state?.streamViewType;
            resourceInputs["tableClass"] = state?.tableClass;
            resourceInputs["tags"] = state?.tags;
            resourceInputs["tagsAll"] = state?.tagsAll;
            resourceInputs["ttl"] = state?.ttl;
            resourceInputs["writeCapacity"] = state?.writeCapacity;
        }
        else {
            const args = argsOrState;
            resourceInputs["attributes"] = args?.attributes;
            resourceInputs["billingMode"] = args?.billingMode;
            resourceInputs["deletionProtectionEnabled"] = args?.deletionProtectionEnabled;
            resourceInputs["globalSecondaryIndexes"] = args?.globalSecondaryIndexes;
            resourceInputs["hashKey"] = args?.hashKey;
            resourceInputs["importTable"] = args?.importTable;
            resourceInputs["localSecondaryIndexes"] = args?.localSecondaryIndexes;
            resourceInputs["name"] = args?.name;
            resourceInputs["onDemandThroughput"] = args?.onDemandThroughput;
            resourceInputs["pointInTimeRecovery"] = args?.pointInTimeRecovery;
            resourceInputs["rangeKey"] = args?.rangeKey;
            resourceInputs["readCapacity"] = args?.readCapacity;
            resourceInputs["region"] = args?.region;
            resourceInputs["replicas"] = args?.replicas;
            resourceInputs["restoreDateTime"] = args?.restoreDateTime;
            resourceInputs["restoreSourceName"] = args?.restoreSourceName;
            resourceInputs["restoreSourceTableArn"] = args?.restoreSourceTableArn;
            resourceInputs["restoreToLatestTime"] = args?.restoreToLatestTime;
            resourceInputs["serverSideEncryption"] = args?.serverSideEncryption;
            resourceInputs["streamEnabled"] = args?.streamEnabled;
            resourceInputs["streamViewType"] = args?.streamViewType;
            resourceInputs["tableClass"] = args?.tableClass;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["ttl"] = args?.ttl;
            resourceInputs["writeCapacity"] = args?.writeCapacity;
            resourceInputs["arn"] = undefined /*out*/;
            resourceInputs["streamArn"] = undefined /*out*/;
            resourceInputs["streamLabel"] = undefined /*out*/;
            resourceInputs["tagsAll"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Table.__pulumiType, name, resourceInputs, opts);
    }
}
exports.Table = Table;
/** @internal */
Table.__pulumiType = 'aws:dynamodb/table:Table';
//# sourceMappingURL=table.js.map