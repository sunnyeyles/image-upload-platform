"use strict";
// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
Object.defineProperty(exports, "__esModule", { value: true });
exports.DbCluster = void 0;
const pulumi = require("@pulumi/pulumi");
const utilities = require("../utilities");
/**
 * Resource for managing an Amazon Timestream for InfluxDB read-replica cluster.
 *
 * > **NOTE:** This resource requires a subscription to [Timestream for InfluxDB Read Replicas (Add-On) on the AWS Marketplace](https://aws.amazon.com/marketplace/pp/prodview-lftzfxtb5xlv4?applicationId=AWS-Marketplace-Console&ref_=beagle&sr=0-2).
 *
 * ## Example Usage
 *
 * ### Basic Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.timestreaminfluxdb.DbCluster("example", {
 *     allocatedStorage: 20,
 *     bucket: "example-bucket-name",
 *     dbInstanceType: "db.influx.medium",
 *     failoverMode: "AUTOMATIC",
 *     username: "admin",
 *     password: "example-password",
 *     port: 8086,
 *     organization: "organization",
 *     vpcSubnetIds: [
 *         example1.id,
 *         example2.id,
 *     ],
 *     vpcSecurityGroupIds: [exampleAwsSecurityGroup.id],
 *     name: "example-db-cluster",
 * });
 * ```
 *
 * ### Usage with Prerequisite Resources
 *
 * All Timestream for InfluxDB clusters require a VPC, at least two subnets, and a security group. The following example shows how these prerequisite resources can be created and used with `aws.timestreaminfluxdb.DbCluster`.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.ec2.Vpc("example", {cidrBlock: "10.0.0.0/16"});
 * const example1 = new aws.ec2.Subnet("example_1", {
 *     vpcId: example.id,
 *     cidrBlock: "10.0.1.0/24",
 * });
 * const example2 = new aws.ec2.Subnet("example_2", {
 *     vpcId: example.id,
 *     cidrBlock: "10.0.2.0/24",
 * });
 * const exampleSecurityGroup = new aws.ec2.SecurityGroup("example", {
 *     name: "example",
 *     vpcId: example.id,
 * });
 * const exampleDbCluster = new aws.timestreaminfluxdb.DbCluster("example", {
 *     allocatedStorage: 20,
 *     bucket: "example-bucket-name",
 *     dbInstanceType: "db.influx.medium",
 *     username: "admin",
 *     password: "example-password",
 *     organization: "organization",
 *     vpcSubnetIds: [
 *         example1.id,
 *         example2.id,
 *     ],
 *     vpcSecurityGroupIds: [exampleSecurityGroup.id],
 *     name: "example-db-cluster",
 * });
 * ```
 *
 * ### Usage with S3 Log Delivery Enabled
 *
 * You can use an S3 bucket to store logs generated by your Timestream for InfluxDB cluster. The following example shows what resources and arguments are required to configure an S3 bucket for logging, including the IAM policy that needs to be set in order to allow Timestream for InfluxDB to place logs in your S3 bucket. The configuration of the required VPC, security group, and subnets have been left out of the example for brevity.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const exampleBucket = new aws.s3.Bucket("example", {
 *     bucket: "example-s3-bucket",
 *     forceDestroy: true,
 * });
 * const example = aws.iam.getPolicyDocumentOutput({
 *     statements: [{
 *         actions: ["s3:PutObject"],
 *         principals: [{
 *             type: "Service",
 *             identifiers: ["timestream-influxdb.amazonaws.com"],
 *         }],
 *         resources: [pulumi.interpolate`${exampleBucket.arn}/*`],
 *     }],
 * });
 * const exampleBucketPolicy = new aws.s3.BucketPolicy("example", {
 *     bucket: exampleBucket.id,
 *     policy: example.apply(example => example.json),
 * });
 * const exampleDbCluster = new aws.timestreaminfluxdb.DbCluster("example", {
 *     allocatedStorage: 20,
 *     bucket: "example-bucket-name",
 *     dbInstanceType: "db.influx.medium",
 *     username: "admin",
 *     password: "example-password",
 *     organization: "organization",
 *     vpcSubnetIds: [
 *         example1.id,
 *         example2.id,
 *     ],
 *     vpcSecurityGroupIds: [exampleAwsSecurityGroup.id],
 *     name: "example-db-cluster",
 *     logDeliveryConfiguration: {
 *         s3Configuration: {
 *             bucketName: exampleBucket.bucket,
 *             enabled: true,
 *         },
 *     },
 * });
 * ```
 *
 * ## Import
 *
 * Using `pulumi import`, import Timestream for InfluxDB cluster using its identifier. For example:
 *
 * ```sh
 * $ pulumi import aws:timestreaminfluxdb/dbCluster:DbCluster example 12345abcde
 * ```
 */
class DbCluster extends pulumi.CustomResource {
    /**
     * Get an existing DbCluster resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    static get(name, id, state, opts) {
        return new DbCluster(name, state, { ...opts, id: id });
    }
    /**
     * Returns true if the given object is an instance of DbCluster.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    static isInstance(obj) {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === DbCluster.__pulumiType;
    }
    constructor(name, argsOrState, opts) {
        let resourceInputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState;
            resourceInputs["allocatedStorage"] = state?.allocatedStorage;
            resourceInputs["arn"] = state?.arn;
            resourceInputs["bucket"] = state?.bucket;
            resourceInputs["dbInstanceType"] = state?.dbInstanceType;
            resourceInputs["dbParameterGroupIdentifier"] = state?.dbParameterGroupIdentifier;
            resourceInputs["dbStorageType"] = state?.dbStorageType;
            resourceInputs["deploymentType"] = state?.deploymentType;
            resourceInputs["endpoint"] = state?.endpoint;
            resourceInputs["failoverMode"] = state?.failoverMode;
            resourceInputs["influxAuthParametersSecretArn"] = state?.influxAuthParametersSecretArn;
            resourceInputs["logDeliveryConfiguration"] = state?.logDeliveryConfiguration;
            resourceInputs["name"] = state?.name;
            resourceInputs["networkType"] = state?.networkType;
            resourceInputs["organization"] = state?.organization;
            resourceInputs["password"] = state?.password;
            resourceInputs["port"] = state?.port;
            resourceInputs["publiclyAccessible"] = state?.publiclyAccessible;
            resourceInputs["readerEndpoint"] = state?.readerEndpoint;
            resourceInputs["region"] = state?.region;
            resourceInputs["tags"] = state?.tags;
            resourceInputs["tagsAll"] = state?.tagsAll;
            resourceInputs["timeouts"] = state?.timeouts;
            resourceInputs["username"] = state?.username;
            resourceInputs["vpcSecurityGroupIds"] = state?.vpcSecurityGroupIds;
            resourceInputs["vpcSubnetIds"] = state?.vpcSubnetIds;
        }
        else {
            const args = argsOrState;
            if (args?.allocatedStorage === undefined && !opts.urn) {
                throw new Error("Missing required property 'allocatedStorage'");
            }
            if (args?.bucket === undefined && !opts.urn) {
                throw new Error("Missing required property 'bucket'");
            }
            if (args?.dbInstanceType === undefined && !opts.urn) {
                throw new Error("Missing required property 'dbInstanceType'");
            }
            if (args?.organization === undefined && !opts.urn) {
                throw new Error("Missing required property 'organization'");
            }
            if (args?.password === undefined && !opts.urn) {
                throw new Error("Missing required property 'password'");
            }
            if (args?.username === undefined && !opts.urn) {
                throw new Error("Missing required property 'username'");
            }
            if (args?.vpcSecurityGroupIds === undefined && !opts.urn) {
                throw new Error("Missing required property 'vpcSecurityGroupIds'");
            }
            if (args?.vpcSubnetIds === undefined && !opts.urn) {
                throw new Error("Missing required property 'vpcSubnetIds'");
            }
            resourceInputs["allocatedStorage"] = args?.allocatedStorage;
            resourceInputs["bucket"] = args?.bucket;
            resourceInputs["dbInstanceType"] = args?.dbInstanceType;
            resourceInputs["dbParameterGroupIdentifier"] = args?.dbParameterGroupIdentifier;
            resourceInputs["dbStorageType"] = args?.dbStorageType;
            resourceInputs["deploymentType"] = args?.deploymentType;
            resourceInputs["failoverMode"] = args?.failoverMode;
            resourceInputs["logDeliveryConfiguration"] = args?.logDeliveryConfiguration;
            resourceInputs["name"] = args?.name;
            resourceInputs["networkType"] = args?.networkType;
            resourceInputs["organization"] = args?.organization;
            resourceInputs["password"] = args?.password ? pulumi.secret(args.password) : undefined;
            resourceInputs["port"] = args?.port;
            resourceInputs["publiclyAccessible"] = args?.publiclyAccessible;
            resourceInputs["region"] = args?.region;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["timeouts"] = args?.timeouts;
            resourceInputs["username"] = args?.username;
            resourceInputs["vpcSecurityGroupIds"] = args?.vpcSecurityGroupIds;
            resourceInputs["vpcSubnetIds"] = args?.vpcSubnetIds;
            resourceInputs["arn"] = undefined /*out*/;
            resourceInputs["endpoint"] = undefined /*out*/;
            resourceInputs["influxAuthParametersSecretArn"] = undefined /*out*/;
            resourceInputs["readerEndpoint"] = undefined /*out*/;
            resourceInputs["tagsAll"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["password"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(DbCluster.__pulumiType, name, resourceInputs, opts);
    }
}
exports.DbCluster = DbCluster;
/** @internal */
DbCluster.__pulumiType = 'aws:timestreaminfluxdb/dbCluster:DbCluster';
//# sourceMappingURL=dbCluster.js.map