"use strict";
// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScheduledQuery = void 0;
const pulumi = require("@pulumi/pulumi");
const utilities = require("../utilities");
/**
 * Resource for managing an AWS Timestream Query Scheduled Query.
 *
 * ## Example Usage
 *
 * ### Basic Usage
 *
 * Before creating a scheduled query, you must have a source database and table with ingested data. Below is a multi-step example, providing an opportunity for data ingestion.
 *
 * If your infrastructure is already set up—including the source database and table with data, results database and table, error report S3 bucket, SNS topic, and IAM role—you can create a scheduled query as follows:
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.timestreamquery.ScheduledQuery("example", {
 *     executionRoleArn: exampleAwsIamRole.arn,
 *     name: exampleAwsTimestreamwriteTable.tableName,
 *     queryString: `SELECT region, az, hostname, BIN(time, 15s) AS binned_timestamp,
 * \x09ROUND(AVG(cpu_utilization), 2) AS avg_cpu_utilization,
 * \x09ROUND(APPROX_PERCENTILE(cpu_utilization, 0.9), 2) AS p90_cpu_utilization,
 * \x09ROUND(APPROX_PERCENTILE(cpu_utilization, 0.95), 2) AS p95_cpu_utilization,
 * \x09ROUND(APPROX_PERCENTILE(cpu_utilization, 0.99), 2) AS p99_cpu_utilization
 * FROM exampledatabase.exampletable
 * WHERE measure_name = 'metrics' AND time > ago(2h)
 * GROUP BY region, hostname, az, BIN(time, 15s)
 * ORDER BY binned_timestamp ASC
 * LIMIT 5
 * `,
 *     errorReportConfiguration: {
 *         s3Configuration: {
 *             bucketName: exampleAwsS3Bucket.bucket,
 *         },
 *     },
 *     notificationConfiguration: {
 *         snsConfiguration: {
 *             topicArn: exampleAwsSnsTopic.arn,
 *         },
 *     },
 *     scheduleConfiguration: {
 *         scheduleExpression: "rate(1 hour)",
 *     },
 *     targetConfiguration: {
 *         timestreamConfiguration: {
 *             databaseName: results.databaseName,
 *             tableName: resultsAwsTimestreamwriteTable.tableName,
 *             timeColumn: "binned_timestamp",
 *             dimensionMappings: [
 *                 {
 *                     dimensionValueType: "VARCHAR",
 *                     name: "az",
 *                 },
 *                 {
 *                     dimensionValueType: "VARCHAR",
 *                     name: "region",
 *                 },
 *                 {
 *                     dimensionValueType: "VARCHAR",
 *                     name: "hostname",
 *                 },
 *             ],
 *             multiMeasureMappings: {
 *                 targetMultiMeasureName: "multi-metrics",
 *                 multiMeasureAttributeMappings: [
 *                     {
 *                         measureValueType: "DOUBLE",
 *                         sourceColumn: "avg_cpu_utilization",
 *                     },
 *                     {
 *                         measureValueType: "DOUBLE",
 *                         sourceColumn: "p90_cpu_utilization",
 *                     },
 *                     {
 *                         measureValueType: "DOUBLE",
 *                         sourceColumn: "p95_cpu_utilization",
 *                     },
 *                     {
 *                         measureValueType: "DOUBLE",
 *                         sourceColumn: "p99_cpu_utilization",
 *                     },
 *                 ],
 *             },
 *         },
 *     },
 * });
 * ```
 *
 * ### Multi-step Example
 *
 * To ingest data before creating a scheduled query, this example provides multiple steps:
 *
 * 1. Create the prerequisite infrastructure
 * 2. Ingest data
 * 3. Create the scheduled query
 *
 * ### Step 1. Create the prerequisite infrastructure
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const test = new aws.s3.Bucket("test", {
 *     bucket: "example",
 *     forceDestroy: true,
 * });
 * const testTopic = new aws.sns.Topic("test", {name: "example"});
 * const testQueue = new aws.sqs.Queue("test", {
 *     name: "example",
 *     sqsManagedSseEnabled: true,
 * });
 * const testTopicSubscription = new aws.sns.TopicSubscription("test", {
 *     topic: testTopic.arn,
 *     protocol: "sqs",
 *     endpoint: testQueue.arn,
 * });
 * const testQueuePolicy = new aws.sqs.QueuePolicy("test", {
 *     queueUrl: testQueue.id,
 *     policy: pulumi.jsonStringify({
 *         Version: "2012-10-17",
 *         Statement: [{
 *             Effect: "Allow",
 *             Principal: {
 *                 AWS: "*",
 *             },
 *             Action: ["sqs:SendMessage"],
 *             Resource: testQueue.arn,
 *             Condition: {
 *                 ArnEquals: {
 *                     "aws:SourceArn": testTopic.arn,
 *                 },
 *             },
 *         }],
 *     }),
 * });
 * const testRole = new aws.iam.Role("test", {
 *     name: "example",
 *     assumeRolePolicy: JSON.stringify({
 *         Version: "2012-10-17",
 *         Statement: [{
 *             Effect: "Allow",
 *             Principal: {
 *                 Service: "timestream.amazonaws.com",
 *             },
 *             Action: "sts:AssumeRole",
 *         }],
 *     }),
 *     tags: {
 *         Name: "example",
 *     },
 * });
 * const testRolePolicy = new aws.iam.RolePolicy("test", {
 *     name: "example",
 *     role: testRole.id,
 *     policy: JSON.stringify({
 *         Version: "2012-10-17",
 *         Statement: [{
 *             Action: [
 *                 "kms:Decrypt",
 *                 "sns:Publish",
 *                 "timestream:describeEndpoints",
 *                 "timestream:Select",
 *                 "timestream:SelectValues",
 *                 "timestream:WriteRecords",
 *                 "s3:PutObject",
 *             ],
 *             Resource: "*",
 *             Effect: "Allow",
 *         }],
 *     }),
 * });
 * const testDatabase = new aws.timestreamwrite.Database("test", {databaseName: "exampledatabase"});
 * const testTable = new aws.timestreamwrite.Table("test", {
 *     databaseName: testDatabase.databaseName,
 *     tableName: "exampletable",
 *     magneticStoreWriteProperties: {
 *         enableMagneticStoreWrites: true,
 *     },
 *     retentionProperties: {
 *         magneticStoreRetentionPeriodInDays: 1,
 *         memoryStoreRetentionPeriodInHours: 1,
 *     },
 * });
 * const results = new aws.timestreamwrite.Database("results", {databaseName: "exampledatabase-results"});
 * const resultsTable = new aws.timestreamwrite.Table("results", {
 *     databaseName: results.databaseName,
 *     tableName: "exampletable-results",
 *     magneticStoreWriteProperties: {
 *         enableMagneticStoreWrites: true,
 *     },
 *     retentionProperties: {
 *         magneticStoreRetentionPeriodInDays: 1,
 *         memoryStoreRetentionPeriodInHours: 1,
 *     },
 * });
 * ```
 *
 * #### Step 2. Ingest data
 *
 * This is done with Amazon Timestream Write [WriteRecords](https://docs.aws.amazon.com/timestream/latest/developerguide/API_WriteRecords.html).
 *
 * ### Step 3. Create the scheduled query
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.timestreamquery.ScheduledQuery("example", {
 *     executionRoleArn: exampleAwsIamRole.arn,
 *     name: exampleAwsTimestreamwriteTable.tableName,
 *     queryString: `SELECT region, az, hostname, BIN(time, 15s) AS binned_timestamp,
 * \x09ROUND(AVG(cpu_utilization), 2) AS avg_cpu_utilization,
 * \x09ROUND(APPROX_PERCENTILE(cpu_utilization, 0.9), 2) AS p90_cpu_utilization,
 * \x09ROUND(APPROX_PERCENTILE(cpu_utilization, 0.95), 2) AS p95_cpu_utilization,
 * \x09ROUND(APPROX_PERCENTILE(cpu_utilization, 0.99), 2) AS p99_cpu_utilization
 * FROM exampledatabase.exampletable
 * WHERE measure_name = 'metrics' AND time > ago(2h)
 * GROUP BY region, hostname, az, BIN(time, 15s)
 * ORDER BY binned_timestamp ASC
 * LIMIT 5
 * `,
 *     errorReportConfiguration: {
 *         s3Configuration: {
 *             bucketName: exampleAwsS3Bucket.bucket,
 *         },
 *     },
 *     notificationConfiguration: {
 *         snsConfiguration: {
 *             topicArn: exampleAwsSnsTopic.arn,
 *         },
 *     },
 *     scheduleConfiguration: {
 *         scheduleExpression: "rate(1 hour)",
 *     },
 *     targetConfiguration: {
 *         timestreamConfiguration: {
 *             databaseName: results.databaseName,
 *             tableName: resultsAwsTimestreamwriteTable.tableName,
 *             timeColumn: "binned_timestamp",
 *             dimensionMappings: [
 *                 {
 *                     dimensionValueType: "VARCHAR",
 *                     name: "az",
 *                 },
 *                 {
 *                     dimensionValueType: "VARCHAR",
 *                     name: "region",
 *                 },
 *                 {
 *                     dimensionValueType: "VARCHAR",
 *                     name: "hostname",
 *                 },
 *             ],
 *             multiMeasureMappings: {
 *                 targetMultiMeasureName: "multi-metrics",
 *                 multiMeasureAttributeMappings: [
 *                     {
 *                         measureValueType: "DOUBLE",
 *                         sourceColumn: "avg_cpu_utilization",
 *                     },
 *                     {
 *                         measureValueType: "DOUBLE",
 *                         sourceColumn: "p90_cpu_utilization",
 *                     },
 *                     {
 *                         measureValueType: "DOUBLE",
 *                         sourceColumn: "p95_cpu_utilization",
 *                     },
 *                     {
 *                         measureValueType: "DOUBLE",
 *                         sourceColumn: "p99_cpu_utilization",
 *                     },
 *                 ],
 *             },
 *         },
 *     },
 * });
 * ```
 *
 * ## Import
 *
 * Using `pulumi import`, import Timestream Query Scheduled Query using the `arn`. For example:
 *
 * ```sh
 * $ pulumi import aws:timestreamquery/scheduledQuery:ScheduledQuery example arn:aws:timestream:us-west-2:012345678901:scheduled-query/tf-acc-test-7774188528604787105-e13659544fe66c8d
 * ```
 */
class ScheduledQuery extends pulumi.CustomResource {
    /**
     * Get an existing ScheduledQuery resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    static get(name, id, state, opts) {
        return new ScheduledQuery(name, state, { ...opts, id: id });
    }
    /**
     * Returns true if the given object is an instance of ScheduledQuery.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    static isInstance(obj) {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ScheduledQuery.__pulumiType;
    }
    constructor(name, argsOrState, opts) {
        let resourceInputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState;
            resourceInputs["arn"] = state?.arn;
            resourceInputs["creationTime"] = state?.creationTime;
            resourceInputs["errorReportConfiguration"] = state?.errorReportConfiguration;
            resourceInputs["executionRoleArn"] = state?.executionRoleArn;
            resourceInputs["kmsKeyId"] = state?.kmsKeyId;
            resourceInputs["lastRunSummaries"] = state?.lastRunSummaries;
            resourceInputs["name"] = state?.name;
            resourceInputs["nextInvocationTime"] = state?.nextInvocationTime;
            resourceInputs["notificationConfiguration"] = state?.notificationConfiguration;
            resourceInputs["previousInvocationTime"] = state?.previousInvocationTime;
            resourceInputs["queryString"] = state?.queryString;
            resourceInputs["recentlyFailedRuns"] = state?.recentlyFailedRuns;
            resourceInputs["region"] = state?.region;
            resourceInputs["scheduleConfiguration"] = state?.scheduleConfiguration;
            resourceInputs["state"] = state?.state;
            resourceInputs["tags"] = state?.tags;
            resourceInputs["tagsAll"] = state?.tagsAll;
            resourceInputs["targetConfiguration"] = state?.targetConfiguration;
            resourceInputs["timeouts"] = state?.timeouts;
        }
        else {
            const args = argsOrState;
            if (args?.errorReportConfiguration === undefined && !opts.urn) {
                throw new Error("Missing required property 'errorReportConfiguration'");
            }
            if (args?.executionRoleArn === undefined && !opts.urn) {
                throw new Error("Missing required property 'executionRoleArn'");
            }
            if (args?.notificationConfiguration === undefined && !opts.urn) {
                throw new Error("Missing required property 'notificationConfiguration'");
            }
            if (args?.queryString === undefined && !opts.urn) {
                throw new Error("Missing required property 'queryString'");
            }
            if (args?.scheduleConfiguration === undefined && !opts.urn) {
                throw new Error("Missing required property 'scheduleConfiguration'");
            }
            if (args?.targetConfiguration === undefined && !opts.urn) {
                throw new Error("Missing required property 'targetConfiguration'");
            }
            resourceInputs["errorReportConfiguration"] = args?.errorReportConfiguration;
            resourceInputs["executionRoleArn"] = args?.executionRoleArn;
            resourceInputs["kmsKeyId"] = args?.kmsKeyId;
            resourceInputs["lastRunSummaries"] = args?.lastRunSummaries;
            resourceInputs["name"] = args?.name;
            resourceInputs["notificationConfiguration"] = args?.notificationConfiguration;
            resourceInputs["queryString"] = args?.queryString;
            resourceInputs["recentlyFailedRuns"] = args?.recentlyFailedRuns;
            resourceInputs["region"] = args?.region;
            resourceInputs["scheduleConfiguration"] = args?.scheduleConfiguration;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["targetConfiguration"] = args?.targetConfiguration;
            resourceInputs["timeouts"] = args?.timeouts;
            resourceInputs["arn"] = undefined /*out*/;
            resourceInputs["creationTime"] = undefined /*out*/;
            resourceInputs["nextInvocationTime"] = undefined /*out*/;
            resourceInputs["previousInvocationTime"] = undefined /*out*/;
            resourceInputs["state"] = undefined /*out*/;
            resourceInputs["tagsAll"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(ScheduledQuery.__pulumiType, name, resourceInputs, opts);
    }
}
exports.ScheduledQuery = ScheduledQuery;
/** @internal */
ScheduledQuery.__pulumiType = 'aws:timestreamquery/scheduledQuery:ScheduledQuery';
//# sourceMappingURL=scheduledQuery.js.map